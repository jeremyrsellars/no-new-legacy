---
title: "Generative Testing Part 6 – Assistance from the Testing Framework"
date: "2019-02-11"
description: "Combining several generators to produce nearly-to-spec strings to trick the system under test."
tags: ["testing", "generative testing", "clojure.spec", "NUnit", "FsCheck"]
categories : ["Programming", "Craft"]
---

* [In part 5]({{urls.base_path}}posts/2019-02-06-generative-testing-the-hard-way) of this discussion of "generative testing", we began to see areas where the unit testing way of doing things just didn't quite fit with generated data.
    * It is easy to generate a bunch of random tests, but when you try to run a specific test again, that example may not have been generated again, then the testing framework can't find the test.  Where do generative testing frameworks come in to help?
    * Tests need to be extensible, so it often isn't sufficient to merely provide one set of generators for use in all tests. We will look at ways of selecting arbitrary generators to use for particular tests.

![F_Parameterized_Test_With_Better_Generators 509 373]({{urls.base_path}}assets/media/F_Parameterized_Test_With_Better_Generators.PNG)

# Test Framework Assistance

## "Reproducible random" test cases

The testing libraries have functions register the property-based tests with the testing framework, so different randomly-generated tests may be run each time.

1. Register tests for execution with random data.
2. Provide a way to reproduce a test when a failing test is discovered.  (This is usually by way of a random seed that can reproduce the same sequence of random values consistently over time and on different machines.)

The same principals apply in Clojure's test.check as many other QuickCheck-inspired libraries, and its easy-to-visualize data results will help us see what is going on.

### Clojure.test & test.check

#### Registering properties to test with `defspec`

The ways in which programmers may plug in to the different testing frameworks help really start to diverge here, but let's start with clojure.test.check's `defspec` macro.  

1. It registers a test with `clojure.test`, so the tests are runable with commands like `lein test` or `(clojure.test/run-tests)`.
2. It defines a function that will test random data and return the result.  See below.

`clojure.test.check.properties/for-all` is like the `clojure.core/for` array comprehension, in that it evaluates its body for each value generated by the generator.  The property being checked returns true for pass and false for failing cases.

In this case, the `sheep-bleat?` always returns false, so it isn't difficult to find a failing test case using our regular expression test oracle. `defspec` does 2 things:

```clojure
(defspec Testing_sheep-bleat?_with_framework
  ; Run the test for each of generated examples
  (prop/for-all [text (s/gen ::f/sheepish-like-string 4)]
    (= (some? (re-find #"^baa+$" text))  ; true when a match is found, false when nil is returned.
       (sheep-bleat? text))))

user=> (Testing_sheep-bleat?_with_framework)
{:result         false,
 :seed           1549940595432,
 :failing-size   6,
 :num-tests      7,
 :fail           ["baaa"],
 :shrunk         {:total-nodes-visited 10, :depth 2, :result false, :smallest ["baa"]}}
```

Let's analyze the output, key by key.

* `:result false` – The test failed
* `:seed 1549940595432` – The random seed that generated the cases, and can be used to reproduce the test.
* `:failing-size 6` – The size/interestingness that generated the test.
* `:num-tests 7` – The number of tests executed.
* `:fail ["baaa"]` – The initial value that caused the test to fail. This is where the shrinking starts.
* `:shrunk`  – Details of the shrinking process.
    * `:total-nodes-visited 10` – The count of distinct variation nodes visit while shrinking.
    * `:depth 2` – The number of shrinking operations performed before getting to the smallest.  Depth is always less-than or equal to total-nodes-visited.
    * `:result false` – `false` means the test failed.
    * `:smallest ["baa"]` – The smallest case that failed.  This is where the shrinking stops.

#### Reproducing a test with `:seed`

After fixing the bug, if we want to run with the same random number generator to reproduce a formerly-failing scenario, we can specify the seed and the number of tests to execute again.

```clojure
user=> (Testing_sheep-bleat?_with_framework 10 :seed 1549940595432)
{:result false, :seed 1549940595432, :failing-size 6, :num-tests 7, :fail ["baaa"], :shrunk {:total-nodes-visited 10, :depth 2, :result false, :smallest ["baa"]}}
```

### FsCheck & NUnit

#### Registering properties to test with `defspec`
#### Reproducing a test with `:seed`

# Source code

If you want to follow along, the source code is here:

* Clojure: https://github.com/jeremyrsellars/no-new-legacy/blob/master/src/sheepish/test/sheepish/g_framework_assisted_sheepish_tests.cljc
--* C#: https://github.com/jeremyrsellars/no-new-legacy/blob/master/src/Sheepish.net/Sheepish.CSharp/F_Parameterized_Test_With_Better_Generators.cs--
