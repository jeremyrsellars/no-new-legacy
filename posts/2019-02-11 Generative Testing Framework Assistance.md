---
title: "Generative Testing Part 6 – The DNA of Test Framework Assistance"
date: "2019-02-11"
revision: "2019-02-12"
description: "Combining several generators to produce nearly-to-spec strings to trick the system under test."
tags: ["testing", "generative testing", "clojure.spec", "NUnit", "FsCheck"]
categories : ["Programming", "Craft"]
---

* [In part 5]({{urls.base_path}}posts/2019-02-06-generative-testing-the-hard-way) of this discussion of "generative testing", we began to see areas where randomly generated data didn't quite fit into the unit testing way of doing things.
    * Tests need to be extensible, so it often isn't sufficient to merely provide one set of generators for use in all tests. We will look at ways of selecting arbitrary generators to use for particular tests.
    * It is easy to generate a bunch of random tests, but when you try to run a specific test again, that example may not have been generated again, then the testing framework can't find the test because different tests were generated each time (both a help and a hinderance).  How do generative testing frameworks help?<br>![F_Parameterized_Test_With_Better_Generators 509 373]({{urls.base_path}}assets/media/F_Parameterized_Test_With_Better_Generators.PNG)

# The DNA of property-based testing

As "DNA" is composed of 4 nucleotides, adenine (A), thymine (T), guanine (G) and cytosine (C), property-based testing frameworks do 4 things for you.

The testing libraries have functions register the property-based tests with the testing framework, so different randomly-generated tests may be run each time.

* A - Add test to framework
    * Register property tests for execution with an identifiable test name.
* T - Test properties you define
    * These functions often take the input and return true when the test passes and false otherwise.
* G - Generate reproducible data
    * Specify which generators will provide the random data for the property tests.
    * Provide a way to reproduce a test when a failing test is discovered, to see if an attempted code fix had the desired effect.  (This is usually by way of a random seed that can reproduce the same sequence of random values consistently over time and on different machines.)
* C - Collapse to the minimal failing case using shrinking.

The specific ways in which programmers may plug into the different testing frameworks help really start to diverge here in this post, but by looking for these 4 parts, you'll see the commonalities between the different libraries.  If you choose a different library for your platform, you can still look for these and use them in a similar manner.

## Clojure.test & test.check

The same principals apply in Clojure's test.check as many other QuickCheck-inspired libraries.  Clojure's easy-to-visualize data results will help us see what is going on.  Watch for the DNA of the property-based tests as we go over each part of this test definition.

```clojure
(defspec sheep-bleat?_matches_oracle                         ; `A`dd named test                         
  (prop/for-all [text (s/gen ::f/sheepish-like-string 4)]    ; Specify `G`enerator(s)
    (= (some? (re-find #"^baa+$" text))                      ; Define property to `T`est
       (sheep-bleat? text))))

user=> (sheep-bleat?_matches_oracle)
{:result         false,
 :seed           1549979449257,
 :failing-size   12,
 :num-tests      13,
 :fail           ["baaaaaa"],                                ; `C`ollapsed from "baaaaaa" to
 :shrunk                                                     ; shrunken test: "baa"
                 {:total-nodes-visited 8, :depth 2, :result false, :smallest ["baa"]}}
```

* *A*dd test – It registers a test with `clojure.test` witha a descriptive name, so the tests are runable with commands like `lein test` or `(clojure.test/run-tests)`.
* *G*enerate reproducible data – `clojure.test.check.properties/for-all` is like the `clojure.core/for` list comprehension, in that it evaluates its expression body for each value generated by the generator.
* *T*est properties – The property is modeled as an expression that compares the "actual" value generated by `(sheep-bleat? text)` to the "expected" value produced by our oracle.
* *C*ollapse – shrink to a smaller failing case to make it easier to troubleshoot.

Let's analyze the output, key by key.

* `:result false` – The test failed
* `:seed 1549979449257` – The random seed that generated the cases, and can be used to reproduce the test.
* `:failing-size 12` – The size/interestingness that generated the test.
* `:num-tests 13` – The number of tests executed.
* `:fail ["baaaaaa"]` – The initial value that caused the test to fail. This is where the shrinking starts.
* `:shrunk`  – Details of the shrinking process.
    * `:total-nodes-visited 8` – The count of distinct variation nodes visit while shrinking.
    * `:depth 2` – The number of shrinking operations performed before getting to the smallest.  Depth is always less-than or equal to total-nodes-visited.
    * `:result false` – `false` means the test failed.
    * `:smallest ["baa"]` – The smallest case that failed.  This is where the shrinking stops.

### Reproducing a test with `:seed`

After fixing the bug, if we want to run with the same random number generator to reproduce a formerly-failing scenario, we can specify the seed and the number of tests to execute again in an attempt to find a example that disproves the assertion.

```clojure
user=> (sheep-bleat?_matches_oracle 100 :seed 1549979449257)
{:result false, :seed 1549979449257, :failing-size 12, :num-tests 13, :fail ["baaaaaa"], :shrunk {:total-nodes-visited 8, :depth 2, :result false, :smallest ["baa"]}}
```

# Source code

If you want to follow along, the source code is here:

* Clojure: https://github.com/jeremyrsellars/no-new-legacy/blob/master/src/sheepish/test/sheepish/g_framework_assisted_sheepish_tests.cljc
--* C#: https://github.com/jeremyrsellars/no-new-legacy/blob/master/src/Sheepish.net/Sheepish.CSharp/F_Parameterized_Test_With_Better_Generators.cs--
