<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<!-- 2016-10-21 ConcurrentDictionary and the pit of success.md 2016-10-21 -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta charset="utf-8">
  <title>ConcurrentDictionary and the Pit of Success - No New Legacy Code Blog - Jeremy Sellars</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, max-scale=1.0">
    <meta name="keywords" content="No New Legacy Code, #&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,#&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,#&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,#&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,#&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,#&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,#&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;, #&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,#&lt;Ruhoh::Views::MasterView:0x00000006666a38&gt;,">
    <meta name="description" content="When a class attempts to implement two different, incompatible semantic behaviors, it can lead to some nasty surprises.  This post explores how a small violation of the Liskov Substitution Principal can lead to unexpected bugs.  ConcurrentDictionary can be accidentally used incorrectly because of a subtle Liskov Substitution Principal violation.">
    <meta name="date" content="2016-10-21">
    <meta name="datePublished" content="2016-10-21">
    <meta name="author" content="Jeremy Sellars">
    <meta name="geo.region" content="US-MO" />

<link href='/no-new-legacy/assets/stylesheets/bootstrap.min-21e719d09459e00e88f455f6a6b959f2.css' type='text/css' rel='stylesheet' media='all'>
<link href='/no-new-legacy/assets/stylesheets/style-38c31e2ffc8c3928e55ee113001f9b38.css' type='text/css' rel='stylesheet' media='all'>
<link href='/no-new-legacy/assets/stylesheets/google_prettify/sons-of-obsidian-0425bd461b9536e97cbae30b357f4711.css' type='text/css' rel='stylesheet' media='all'>
<link href='/no-new-legacy/assets/stylesheets/application-f9c5bae578f98e2ad24d2a29a1f7f52b.css' type='text/css' rel='stylesheet' media='all'>
  <!-- http://www.favicon-generator.org/ -->
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/media/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/media/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/media/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/media/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/media/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/media/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/media/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/media/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/media/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/media/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/media/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/media/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/media/favicon-16x16.png">
  <link rel="manifest" href="/assets/media/manifest.json">
  <meta name="msapplication-TileColor" content="#753636">
  <meta name="msapplication-TileImage" content="/assets/media/ms-icon-144x144.png">
  <meta name="theme-color" content="#753636">
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
  <!--[if IE 6]><link href="default_ie6.css" rel="stylesheet" type="text/css" /><![endif]-->

  <!--{ { { widgets.analytics }}} -->

</head>
<body itemscope="" itemtype="http://schema.org/WebPage">
<div id="header" tabindex="0" hidefocus="true">
  <div class="container">
    <div id="logo">
      <h1><a href="/no-new-legacy/">No New Legacy Code</a></h1>
    </div>
    <div id="menu">
      <ul class="nav">
          
            <li><a href="/no-new-legacy/archive">Archive</a></li>
          
          
            <li><a href="/no-new-legacy/tags">Tags</a></li>
          
          
            <li><a href="/no-new-legacy/categories">Categories</a></li>
          
          
            <li><a href="/no-new-legacy/pages">Pages</a></li>
          
      </ul>
    </div>
  </div>
</div>

<div id="wrapper">
  <div id="page" class="container">
    <div id="content" itemprop="mainContentOfPage">
      
<div class="page-header">
  <div class="span12">
    <h1>ConcurrentDictionary and the Pit of Success </h1>
  </div>
</div>

<div class="post-full">
  <div class="span12">
    <div class="date">
      <span>2016-10-21</strong>
    </div>
    <div class="content">
      <p>When it comes to managing state in .NET, ConcurrentDictionary is not a silver bullet.  When a data structure attempts to implement two different, incompatible semantic behaviors, it can lead to some nasty surprises.  This post explores how a &quot;small&quot; violation of the Liskov Substitution Principal can lead to unexpected bugs.  ConcurrentDictionary can be accidentally used incorrectly because of a subtle Liskov Substitution Principal violation.</p>

<h1 id="toc_0">Thread-safety of ConcurrentDictionary</h1>

<p>Imagine implementing a cache with a dictionary.  Some threads add dictionary entries, and a maintenance thread selectively removes old entries.  Perhaps you wonder, what about that new namespace <code>System.Collections.Concurrent</code>... Would the <a href="https://msdn.microsoft.com/en-us/library/dd287191%28v=vs.110%29.aspx"  target="_blank" title="" rel="noopener" class="external">ConcurrentDictionary</a> let any thread mutate it without having to use explicit locking or having to think of the consequences?</p>

<h2 id="toc_1">Research</h2>

<p>I did not know whether the ConcurrentDictionary could be enumerated safely while being modified in another thread.  I set out to answer the question &quot;Is ConcurrentDictionary any more thread-safe than Dictionary?&quot;  <code>ConcurrentDictionary</code>&#39;s <a href="" target="_blank" title="">thread-safety disclaimer</a> does <em>not</em> indicate to me that it would be safe to enumerate, but it <em>has to be</em> safe, right? (Spoiler!  Answer: not always).</p>

<blockquote>
<p>All public and protected members of ConcurrentDictionary&lt;TKey, TValue&gt; are thread-safe and may be used concurrently from multiple threads. However, <strong>members accessed through one of the interfaces the ConcurrentDictionary&lt;TKey, TValue&gt; implements, including extension methods, are not guaranteed to be thread safe</strong> and may need to be synchronized by the caller.</p>
</blockquote>

<p>(*emphasis* mine)</p>

<p>This guarantee applies to <a href="https://msdn.microsoft.com/en-us/library/dd287109%28v=vs.110%29.aspx?f=255&MSPPError=-2147217396"  target="_blank" title="" rel="noopener" class="external">ConcurrentDictionary.ToArray()</a>, so that would seem a safe choice to convert the dictionary to something enumerable.  But what about using <code>GetEnumerator</code> (like from a <code>foreach</code> statement in C#)?</p>

<p>What about the <a href="https://msdn.microsoft.com/en-us/library/dd287131%28v=vs.110%29.aspx"  target="_blank" title="" rel="noopener" class="external">enumerator</a> used by <code>foreach</code>?</p>

<blockquote>
<p>The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary. The contents exposed through the enumerator may contain modifications made to the dictionary after <code>GetEnumerator</code> was called.</p>
</blockquote>

<p>I set up a small console project to see how enumeration would work while concurrently adding or removing entries using:</p>

<ul>
<li>C#&#39;s <code>foreach</code> (<code>.GetEnumerator()</code>)</li>
<li>Linq&#39;s <code>.ToList()</code></li>
<li>F#&#39;s <code>ofSeq</code></li>
</ul>

<pre><code class="c-sharp">static void Main()
{
    WriteLine(&quot;TEST #1 - Enumerate while adding&quot;);
    WriteLine(&quot;-------------------------------------------------------------------------------&quot;);
    WriteLine(&quot;Add many entries in one thread, while reading entries with other threads.&quot;);
    WriteLine();
    MainAdd();

    dict.Clear();

    WriteLine();
    WriteLine(&quot;TEST #2 - Enumerate while removing&quot;);
    WriteLine(&quot;-------------------------------------------------------------------------------&quot;);
    WriteLine(&quot;Remove many entries in one thread, while reading entries with other threads.&quot;);
    WriteLine();
    MainRemove();
}

static void MainAdd()
{
    var threads = new[] {
        new Thread(AddEntries),
        new Thread(EnumerateWithForeachCount),
        new Thread(EnumerateWithLinqCount),
        new Thread(EnumerateWithFsharpCount),
    };
    foreach (var t in threads)
        t.Start();
    foreach (var t in threads)
        t.Join();
}

static void MainRemove()
{
    AddEntries();
    var threads = new[] {
        new Thread(RemoveEntries),
        new Thread(EnumerateWithForeach0),
        new Thread(EnumerateWithLinq0),
        new Thread(EnumerateWithFsharp0),
    };
    foreach (var t in threads)
        t.Start();
    foreach (var t in threads)
        t.Join();
}
</code></pre>

<p>You can see the rest of the code here in the <a href="https://gist.github.com/a3394f791ae1759d19a40beacf5e143c"  target="_blank" title="" rel="noopener" class="external">gist</a>.  Here are the results.</p>

<p>Now original the project that raised this question was written in F#.  But since more people &quot;speak&quot; C#, that&#39;s the language I used for my test.  <strong>So I started with a Linq implementation and it threw an exception that I did not expect.</strong>  So I tried almost the same thing, but this time with the F# libraries used in idiomatic F# (easily referenced from the C# project). It worked just fine (I was not able to make it fail with FSharp&#39;s <code>SeqModule.OfSeq</code>, or with a Linq <code>where</code> filter, or by using the enumerator directly.)</p>

<p>Here is a more complete test program output, now that I understand the problem.</p>

<h4 id="toc_2">TEST #1 - Enumerate while adding</h4>

<p>Add many entries in one thread, while reading entries with other threads.</p>

<ul>
<li>Linq    - Failed with:

<ul>
<li>System.ArgumentException: The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array.</li>
<li>at System.Collections.Concurrent.ConcurrentDictionary&#x60;2.System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>&gt; <strong>.CopyTo(KeyValuePair&#x60;2&#91;&#93; array, Int32 index)</strong></li>
<li>at System.Collections.Generic.List&#x60;1..ctor(IEnumerable&#x60;1 collection)</li>
<li>at System.Linq.Enumerable.ToList&#91;TSource&#93;(IEnumerable&#x60;1 source)</li>
<li>at ConcurrentDictTest.Program.EnumerateWithLinq(Int32 expectedCount)</li>
</ul></li>
<li>Done adding 100000</li>
<li>Foreach - Successfully enumerated. Count: 100000</li>
<li>F#      - Successfully enumerated. Count: 100000</li>
</ul>

<h4 id="toc_3">TEST #2 - Enumerate while removing</h4>

<p>Remove many entries in one thread, while reading entries with other threads.</p>

<ul>
<li>Done adding 100000</li>
<li>Linq    - Failed with:

<ul>
<li>System.Exception: <strong>Somehow the dictionary returned a null.</strong></li>
<li>at ConcurrentDictTest.Program.EnumerateWithLinq(Int32 expectedCount)</li>
</ul></li>
<li>Done removing.  Count:  0</li>
<li>F#      - Successfully enumerated. Count: 0</li>
<li>Foreach - Successfully enumerated. Count: 0</li>
</ul>

<h3 id="toc_4">Linq&#39;s .ToList() fails, and F# succeeds.  What is going on?!</h3>

<p>Digging deeper, I found that when I used <code>ConcurrentDictionary.ToList()</code> (Linq extension methed) to create a <code>List&lt;T&gt;</code>, it threw an exception with <code>ICollection&lt;T&gt;.CopyTo</code> in the stack trace.  So that is verifiably <em>not thread safe</em>.</p>

<h2 id="toc_5">Analysis: Where is the design flaw?</h2>

<p>Linq&#39;s <code>List&lt;T&gt; Enumerable.ToList&lt;T&gt;(this IEnumerable&lt;T&gt; items)</code> is an extension method that takes an Enumerable and returns a list.  It ultimately calls the List<T> constructor, passing in the IEnumerable, which in turn attempts a performance optimization by using ICollection<T>.CopyTo to copy into the new list&#39;s internal array.  So Linq/List is using ConcurrentDictionary, despite the documented warning saying &quot;extension methods are not guaranteed to be thread safe&quot;.</p>

<h4 id="toc_6">Is ConcurrentDictionary at fault?</h4>

<p>Wait ConcurrentDictionary&#39;s thread-safety disclaimer told as much - Only trust the explicit members, not the members accessed through an implemented interface (like <code>ICollection&lt;T&gt;</code>). So surely <code>ConcurrentDictionary</code> is not at fault. (But please delay judgement.)</p>

<h3 id="toc_7">Ok, so Linq is using ConcurrentDictionary wrong.  Is it Linq&#39;s fault?</h3>

<p>In this example, <code>List(IEnumerable&lt;T&gt;)</code> is using ConcurrentDictionary in an unsafe way and it is even documented.  Should we consider this performance optimization premature and dangerous?</p>

<h3 id="toc_8">Judgement: List vs. ConcurrentDictionary</h3>

<p>List&#39;s <code>List(IEnumerable&lt;T&gt;)</code> constructor uses a valid, type-safe transformation (is/cast).  List is not at fault.</p>

<p>The problem is not a documentation problem, and not a implementation problem - the implementation of the interface is correct.  <strong>The problem is a semantic conflict.</strong></p>

<p>There is an implicit, semantic assumption (effectively a requirement) in <code>ICollection&lt;T&gt;</code> - that the collection won&#39;t shrink or grow between asking its count and copying its contents.  This concurrent data structure also attempts to implement the thread-safe-mutation semantic, but it fails to deliver on <code>ICollection&lt;T&gt;</code>&#39;s semantic assumption.</p>

<h2 id="toc_9">Liskov Substitution Principal</h2>

<p>This is where Barbara Liskov&#39;s notion of &quot;behavioral&quot; subtyping, commonly known as the Liskov Substitution Principal, shines as a principal that helps us avoid this kind of design flaw.</p>

<blockquote>
<p>Liskov&#39;s notion of a behavioral subtype defines a notion of substitutability for objects; that is, if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program (e.g. correctness).</p>
</blockquote>

<p>From <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"  target="_blank" title="" rel="noopener" class="external">Wikipedia</a></p>

<p>Here is my rephrasing of the LSP, which trades a bit of fidelity for ease of remembering:</p>

<blockquote>
<p>If you call something a (subtype of) duck, it had better look like a duck and quack like one.</p>
</blockquote>

<p>In other words to follow the Liskov Substitution Principal:</p>

<ul>
<li>If you implement an interface, implementations (sub-types) of that interface must honor the semantic assumptions in the interface.</li>
<li>The same applies for many similar abstractions:

<ul>
<li>Derived classes</li>
<li>Action delegates, lambda functions, etc..</li>
<li>Implementations of <a href="http://clojure.org/reference/protocols"  target="_blank" title="" rel="noopener" class="external">protocols</a></li>
</ul></li>
</ul>

<h3 id="toc_10">Related SOLID principals</h3>

<h4 id="toc_11">Interface Segregation Principal and Single Responsibility Principal</h4>

<p>It is easier to follow the LSP when there are fewer semantic assumptions and/or fewer members in the interface.  This brings up the Interface Segregation Principal, which leads to more interfaces with fewer members.  The interfaces aren&#39;t so much about the &quot;thing&quot; (entity or noun) as they are the usage patterns.  For example, instead of having a single <code>IAuditRepository</code>, it can be helpful to break it further into:</p>

<ol>
<li>An interface about recording (inserting) audit records might have a single method.  <code>IAuditRecorder</code></li>
<li>An interface about retrieving existing audit records for display or analysis might be read-only.  <code>IAuditReader</code></li>
<li>An interface about exporting audit records to a different system. <code>IAuditExporter</code></li>
</ol>

<p>In practice, the implementation of these interfaces may be provided by a single <code>class AuditRepository : IAuditRecorder, IAuditReader</code>, but it does not have to be.  By isolating the responsibilities (Single Responsibility Principal) and behavior patterns (Interface Segregation Principal), the system will be more &quot;soft,&quot; flexible, and easy to change.</p>

<h1 id="toc_12">Concluding remarks</h1>

<ul>
<li>We ended up determining that ConcurrentDictionary was safe to use in this case and was prettier than the alternatives (in this case <em>rewriting</em> with immutability or using explicit locking).  So, we used it.</li>
<li>ConcurrentDictionary can easily be used incorrectly with idiomatic C# (Linq). So much for making it easy to fall into the &quot;pit of success&quot;!</li>
<li>ConcurrentDictionary can be a useful tool, but it is not a &quot;silver bullet.&quot;  I consider it &quot;advanced&quot; (in a bad way) and I will avoid it when better a better solution presents itself.</li>
<li>This is not meant to be a rant.  Many .Net collection types have LSP violations, but that was a necessary evil given the historical context.  They are more versatile that way.  They are tools - tools that can be used well or used poorly.  They have evolved over the years and their maintainers valiantly strive to maintain backwards-compatibility so we developers can get the most from the .Net Framework.  These are not easy tasks and I want to applaud their efforts and thank them for a job well done.  I am confident that these LSP violations would be better-addressed if they had it to do over again.</li>
<li>From my perspective, <a href="https://msdn.microsoft.com/en-us/library/dn467181%28v=vs.111%29.aspx?f=255&MSPPError=-2147217396"  target="_blank" title="" rel="noopener" class="external"><code>System.Collections.Immutable.ImmutableDictionary</code></a> is much easier to wrap my head around because it is thread safe, end of story.  I like options that are easier to understand and easier to implement (code is written once and read often).</li>
</ul>

<p>I briefly mentioned the &quot;Pit of Success&quot;.  Usually, professional programmers do not labor in isolation.  When professionals design software and interfaces, we don&#39;t just dig a bear trap, post a sign at the trailhead, and walk away.  We don&#39;t rely on our peers to read the documentation and assume they will avoid the troublesome spots we&#39;ve created. Professionals follow the principal of least surprise.</p>

<p>Legacy Software is scary to change because even the smallest change carries the fear of breaking something.  By using SOLID principals, professionals make it easier to use the APIs correctly and take away the opportunities for surprise.</p>

<p>Thanks for reading.  Cheers,</p>

<ul>
<li>Jeremy</li>
</ul>

<h2 id="toc_13">More On These Subjects</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle#Principle"  target="_blank" title="" rel="noopener" class="external">Liskov Substitution Principal</a> - if you call something a duck, it had better look like a duck and quack like one.</li>
<li><a href="https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29#Overview"  target="_blank" title="" rel="noopener" class="external">SOLID Principals of Object-Oriented Design</a></li>
</ul>

    </div>
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      <li>
        <a href="/no-new-legacy/categories#programming-ref">programming <span>2</span></a>
      </li>
      <li>
        <a href="/no-new-legacy/categories#professionalism-ref">professionalism <span>3</span></a>
      </li>
    </ul>
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      <li>
        <a href="/no-new-legacy/tags#state-management-ref">state-management <span>2</span></a>
      </li>
      <li>
        <a href="/no-new-legacy/tags#SOLID-ref">SOLID <span>1</span></a>
      </li>
      <li>
        <a href="/no-new-legacy/tags#Liskov-substitution-principal-ref">Liskov-substitution-principal <span>1</span></a>
      </li>
      <li>
        <a href="/no-new-legacy/tags#multi-threaded-code-ref">multi-threaded-code <span>1</span></a>
      </li>
      <li>
        <a href="/no-new-legacy/tags#.net-ref">.net <span>1</span></a>
      </li>
      <li>
        <a href="/no-new-legacy/tags#c#-ref">c# <span>1</span></a>
      </li>
      <li>
        <a href="/no-new-legacy/tags#abstraction-ref">abstraction <span>1</span></a>
      </li>
    </ul>
    <hr>
    <div class="pagination">
      <ul>
          <li class="prev"><a href="/no-new-legacy/posts/2016-09-27-functional-state-management-in-net" title="Functional State Management (in .Net)">&larr; Previous</a></li>

          <li><a href="/no-new-legacy/archive">Archive</a></li>

          <li class="next disabled"><a>Next &rarr;</a>
      </ul>
    </div>
    <hr>
    
  </div>
</div>


    </div>
  </div>
</div>

<div id="footer" itemscope="" itemtype="http://schema.org/LocalBusiness">
      <div class="footer">
        <p>&copy; <a href="https://github.com/jeremyrsellars" itemprop="copyrightHolder">Jeremy Sellars</a> <span itemprop="copyrightYear">2015 - 2016</span>2015-2016
          with help from <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>.
          <br>Theme based on <a href="https://templated.co/fullstrength" rel="nofollow" target="_blank">FullStrength</a> template from <a href="http://templated.co" rel="nofollow" target="_blank">TEMPLATED</a>

        </p>
      </div>

    </div> <!-- /container -->

    <!-- Google Prettify -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>
<!-- end Google Prettify -->
    

<script>
  try
  {
    window.onload = function() {
      if(document.getElementById)document.getElementById("header").focus();
    };
  }
  catch(e)
  {
  }
</script>
</body>
</html>
